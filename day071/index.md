从睡眠排序法说开去
"睡眠排序",源于段子.
```
public class SleepSort {  
	
    public static void main(String[] args) {  
    	
        int[] arr = {1,4,7,3,8,9,2,6,5};
        //创建指定长度的线程数组
        SortThread[] sortThreads = new SortThread[arr.length];  
        //指定每个线程数组的值
        for (int i = 0; i < sortThreads.length; i++) {  
            sortThreads[i] = new SortThread(arr[i]);  
        } 
        //开启每个线程
        for (int i = 0; i < sortThreads.length; i++) {  
            sortThreads[i].start();  
        }  
    }  
}  
class SortThread extends Thread{  
    int s = 0;  
    public SortThread(int s){  
        this.s = s;  
    }  
    public void run(){  
        try {  
            sleep(s*10+10);  //睡眠指定的时间
        } catch (InterruptedException e) {  
              
            e.printStackTrace();  
        }  
        //输出该数
        System.out.println(s);  
    }  
}  

```

当然,都可以看出这个算法是扯淡的,是不可行的.这个不需要太多勇气.
但是,从不可行的东西里看出可行.这个需要一点运气.

排序的本质,是偏序性.自然数是有偏序性的,所以可以排序.
没有偏序性,就没有排序的概念.
时间也是有偏序性的.

不管快速排序还是冒泡还是其他排序.
在Java里大都需要实现个Compare接口.
这个接口有两个参数,返回一个整数.
这两个参数是两个要比较的对象,返回的整数,是自然数.
利用返回数的正负性,来体现偏序性的前还是后.
这个是经典排序的根基.
没有这个根基,就没有那些算法.因为那些算法,在我看来,某种程度上只是调度器.
什么意思?就是怎么分配内存,怎么分配任务,让排序工作好一点,快一点完成.
很多时候,我们讨论排序算法的时候,其实讨论的是关于排序的调度算法.

下面我说的睡眠排序法.
它的本质也和上面一样,也是利用偏序性.但是,它的漂亮之处是,它用了个中间桥梁.
我们知道,时间是具有偏序性的.
它通过数据->时间进行映射,将自身的偏序性,附加到时间的偏序性上,然后通过时间的对比,来体现原数据的偏序,也就是对原数据进行排序.

原来的排序是 A <->A 这种的.
现在的排序方法是 A<- C <-> C ->A 这种的.

这是一种新的模型.它的缺点很明显. 但是优点也很独特.
它最大的优点是,A是可以独立的了,节点间不需要比较或者通讯. 表现在方法上就是sleep函数只有一个参数.
Compare函数是需要两个参数的.两个意味着群体.
sleep排序的重大意义是它是独立的,它不需要全局感知.说不清楚,但是可以预感,这种独立性具有重大价值.
这也是我为什么费这么大劲去思考这个目前看来非常扯淡,根本不能用的排序.


下面来说说sleep函数的本质.它的本质是一个返回时间与入参正相关的函数.
这种正相关,保证了A的偏序性可以附加到时间的偏序性上面.

我们说说它的优势,对于排序后取前N条的这种场景,(这个场景目前是我特定的),它只依赖与前N条数据第N条数据的返回时间.
而不依赖于数据量的大小.
100条数据的排序前N条,和10000000条数据排序前N条是一样的返回时间,(假设前N条数据是一样的).

最现实的比喻,其实就是马拉松,一群人跑马拉松,取前N名记名词.

我们怎么来实现这个算法?
这个算法有几个关键点.难题很多.但是应该还是有机会解决的.
1. 需要安排到同一起跑线上.
以时间为中间参考,这需要各个节点有同一个时空. 但是,不管狭义相对论还是广义相对论,同一个时空,这个条件很难满足.
所以,第一个难题就是时空同步的问题.
这个解决思路我还没有.

2. 假设我们解决了时空同步的问题,各个计算节点(时空)都是对过表了,那么一声枪响,各个节点开始sleep,也就是运行自己的那个与时间正相关的函数.
这个函数需要精细设计,sleep理论上是满足需求的,现实上是不能接受的.这个矛盾需要处理.
实践上,我们可以把这个sleep函数换成迭代,假设我们以某个指令为基本单元,指令执行的次数为单位1,sleep n 可以使用执行n次指令替换掉. 它们是等价类,这是一个变换.
在这个变换的基础上,我们再改一点,这n次指令我们用一个函数换掉,我们知道,经常有些计算,需要迭代逐步逼近.
比如求个π的N位.或者大数分解一下? 总之,有很多现成的需要不断的循环去执行的函数,每次循环的消耗是固定的.
这样的函数就类似一个稳定自旋的原子.我们需要做的是,把我们的函数附加到这个原子上.
我们通过附加自身逻辑到这种陀螺函数上,共享了计算.这就类似于每天都有往返某地的火车,我们可以把自己的包裹通过火车传送,
而不是自己开个车去亲自送.

3. 现在第三个问题是,这样的火车哪里找?
我们可以自己构造,但是这里其实还是有一个方向.
在云计算环境下,虚拟化技术大家肯定都了解过,比如虚拟机,docker等.
我们知道,这些虚拟的底层其实也是跑在操作系统上的程序. 比如docker,它更轻量级,它就是宿主机上的进程.
假设有两个容器,都是跑Java应用.如果你机器很多,容器很多,出现重复的比如相同版本的JVM的概率就很大了.
那么对于重复的这部分,能不能复用?怎么复用? 当你考虑复用,并且实现了复用的时候.
我的意思是,在云计算的环境下,这样的可以承载陀螺函数的火车必然会出现.
如果我们能从底层上开放一个陀螺接口出来,这样我的这个睡眠排序算法就可以附加在其他资源上运行.
就像小包裹丢在火车上一样.

4. 这个有没有其他硬件可以实现?
    GPU是可以考虑的.
    但是时空同步的问题得先解决.
    陀螺函数也是可以构造的. 机器学习很多算法需要迭代. 可以在某个算法里,打开个缺口,构造个陀螺函数,开放个接口出来.
这是关于我最后提的问题的几点扩展.

个人对睡眠排序的结论:
在大数据量并行,(好像叫MPP架构),睡眠排序是有生存空间的. 
算法跑的快不快,土壤很重要.举个例子,go 里面开成百上千个goroute没问题,Java里面开线程就是不行.但是逻辑本质是一样的,都是独立的运行单元.

最后我说几点感受,
1. JVM这个空间其实还是小,会局限思维的.思维这东西,像气球,高了可以一步一步掉下来,但是一开始掉下来就很难再高起来了.
    技术的发展,短期看是要靠基础,靠熟能生巧,靠经验,也就是知道多少黑魔法(这些黑魔法其实都是bug,版本升级一下,就什么都不是了),
    长远了看,得靠想象力.

2. 有本书叫<<大话Java性能优化>>,其实所有的章节都看过,就目前而言,几次面试内容无出其右,
其实还是希望面试内容能不要再在书上可以翻到.当然,翻到了我还这么渣,说来说去,其实我不合适.水平还是差.
写代码不专业.这个得承认.

最后,感谢空印对我的支持与认可,感谢简襄,很辛苦,他两简直为我操碎了心,我这阿斗扶不起,估计也是醉了,哈哈.
李禹是带我入门的师傅,我从他身上学到了谦虚,谨慎.不出意外,这个会影响一生.师傅领进门,修行在个人.
我之前可能还是脆弱,但是现在已经过了需要一个认可的阶段.
今年呢,二十八,人生脑力最巅峰的时候,我个人其实很乐意自己去写个GC,即使这个GC很渣,需要被GC,
但是一点也不愿意去琢磨其他人的GC到底怎么实现的.
不是狂妄,自负,而是实在是,大好青春,其实还是辜负不得的.得琢磨点自己喜欢的东西.再两年,谢顶了就来不及了.
最后,谢谢各位啦.都是很好的小伙伴.
